#include <iostream>
#include <vector>
using namespace std;

int main()
{
  srand(time(nullptr)); // Инициализирует генератор случайных чисел текущим временем

  int r_int = 4 + rand() % 4; // Генерирует случайное целое число от 4 до 7 включительно

  std::vector<float> arr(r_int); // Объявляет массив переменного размера из r_int элементов типа float

  float negSum = 0.0;     // Переменная для накопления суммы отрицательных элементов
  float multipleEven = 1; // Переменная для накопления произведения элементов с чётными индексами (кроме 0)
  cout << "Массив: ";     // Выводит заголовок перед элементами массива

  for (int i = 0; i < r_int; i++) // Цикл для заполнения и обработки каждого элемента
  {
    // Генерирует случайное вещественное число в диапазоне [-100.0, 100.0]:
    // rand() / RAND_MAX — число от 0.0 до 1.0; умножаем на 200 и сдвигаем на -100
    arr[i] = -100.0 + static_cast<float>(rand()) / RAND_MAX * 200.0;

    if (arr[i] < 0) // Если текущий элемент отрицательный
    {
      negSum += arr[i]; // Добавляем его к сумме отрицательных чисел
    }

    // Если индекс чётный и не равен нулю (т.е. i = 2, 4, 6, ...)
    if ((i % 2 == 0) && (i != 0))
    {
      multipleEven *= arr[i]; // Умножаем элемент на накопленное произведение
    }

    cout << arr[i] << " "; // Выводим текущий элемент массива
  }

  // Инициализируем минимум и максимум первым элементом массива
  float max = arr[0]; // Предполагаем, что первый элемент — максимальный
  float min = arr[0]; // Предполагаем, что первый элемент — минимальный
  int indexMax = 0;   // Индекс максимального элемента
  int indexMin = 0;   // Индекс минимального элемента

  // Цикл для поиска реальных минимального и максимального значений и их индексов
  for (int i = 0; i < r_int; i++)
  {
    if (max < arr[i]) // Если найдено значение больше текущего максимума
    {
      max = arr[i]; // Обновляем максимум
      indexMax = i; // Запоминаем его индекс
    }
    if (min > arr[i]) // Если найдено значение меньше текущего минимума
    {
      min = arr[i]; // Обновляем минимум
      indexMin = i; // Запоминаем его индекс
    }
  }

  // Вывод отладочной информации: индекс минимума, индекс максимума и размер массива
  cout << "\n"
       << indexMin << " " << indexMax << " " << r_int;

  float multiple; // Переменная для хранения произведения элементов между позициями минимума и максимума (включительно)

  // Определяем порядок индексов и перемножаем элементы в диапазоне между ними
  if (indexMax > indexMin)
  {
    multiple = arr[indexMin];                      // Начинаем с элемента с меньшим индексом
    for (int i = indexMin + 1; i <= indexMax; i++) // Перемножаем все элементы до indexMax включительно
    {
      multiple *= arr[i];
    }
  }
  else
  {
    multiple = arr[indexMax];                      // Начинаем с элемента с меньшим индексом (indexMax)
    for (int i = indexMax + 1; i <= indexMin; i++) // Перемножаем до indexMin включительно
    {
      multiple *= arr[i];
    }
  }

  int firstNeg = -1; // Инициализируем индекс первого отрицательного элемента значением -1 (означает "не найден")
  int lastNeg = -1;  // Инициализируем индекс последнего отрицательного элемента значением -1 (означает "не найден")

  // Поиск первого отрицательного элемента — проходим массив с начала
  for (int i = 0; i < r_int; i++)
  {
    if (arr[i] < 0) // Если текущий элемент отрицательный
    {
      firstNeg = i; // Запоминаем его индекс
      break;        // Прерываем цикл — нам нужен только первый такой элемент
    }
  }

  // Поиск последнего отрицательного элемента — проходим массив с конца
  for (int i = r_int - 1; i >= 0; i--)
  {
    if (arr[i] < 0) // Если текущий элемент отрицательный
    {
      lastNeg = i; // Запоминаем его индекс
      break;       // Прерываем цикл — нам нужен только последний такой элемент
    }
  }

  float sumBetweenNeg = 0.0; // Переменная для накопления суммы элементов между первым и последним отрицательными

  // Проверяем три условия:
  // 1. Найден ли хотя бы один отрицательный элемент (firstNeg != -1)
  // 2. Найден ли последний отрицательный (lastNeg != -1)
  // 3. Есть ли хотя бы один элемент МЕЖДУ ними (firstNeg < lastNeg - 1)
  if (firstNeg != -1 && lastNeg != -1 && firstNeg < lastNeg - 1)
  {
    // Суммируем элементы, начиная со следующего после firstNeg и до предшествующего lastNeg
    for (int i = firstNeg + 1; i < lastNeg; i++)
    {
      sumBetweenNeg += arr[i]; // Добавляем текущий элемент к сумме
    }
  }

  cout << "\n";
  cout << "Сумма отрицательных значений массива: " << negSum << "\n";                // Вывод суммы отрицательных элементов
  cout << "Произведение значений в диапазоне min max массива: " << multiple << "\n"; // Вывод произведения элементов между позициями минимума и максимума
  cout << "Произведение значений с чётным индексом " << multipleEven << "\n";        // Вывод произведения элементов с чётными индексами (кроме 0)
  cout << "Сумма элементов между первым и последним отрицательными: " << sumBetweenNeg << "\n"; // Вывод суммы элементов, находящихся между первым и последним отрицательными элементами.
}